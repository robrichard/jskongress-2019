<!DOCTYPE html>
<html>
  <head>
    <title>Streaming HTTP and GraphQL</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <style type="text/css">
      /*! global/fonts */
      @font-face {
        font-family: Miller Display Light;
        src: url('https://a.1stdibscdn.com/dist/fonts/MillerDisplay/MillerDisplay-Light.woff')
          format('woff');
        font-weight: 400;
        font-style: normal;
      }

      @font-face {
        font-family: Miller Display Light Italic;
        src: url('https://a.1stdibscdn.com/dist/fonts/MillerDisplay/MillerDisplay-LightItalic.woff')
          format('woff');
        font-weight: 400;
        font-style: normal;
      }

      @font-face {
        font-family: Proxima Nova Light;
        src: url('https://a.1stdibscdn.com/dist/fonts/ProximaNova/ProximaNova-Light.woff')
          format('woff');
        font-weight: 400;
        font-style: normal;
      }

      @font-face {
        font-family: Proxima Nova Light Italic;
        src: url('https://a.1stdibscdn.com/dist/fonts/ProximaNova/ProximaNova-LightItalic.woff')
          format('woff');
        font-weight: 400;
        font-style: normal;
      }

      @font-face {
        font-family: Proxima Nova SemiBold;
        src: url('https://a.1stdibscdn.com/dist/fonts/ProximaNova/ProximaNova-Sbold.woff')
          format('woff');
        font-weight: 400;
        font-style: normal;
      }

      body {
        font-family: 'Proxima Nova Light';
        color: #222;
      }
      h1,
      h2,
      h3 {
        font-family: 'Miller Display Light';
        font-weight: 400;
      }

      .remark-slide-content h1,
      h1 .remark-inline-code {
        font-size: 38px !important;
      }

      .remark-slide-content h2 {
        font-size: 32px !important;
      }

      .remark-slide-content h3 {
        font-size: 26px;
      }

      .remark-slide-content li {
        font-size: 32px;
        line-height: 1.6;
      }

      .remark-code,
      .remark-inline-code {
        font-family: courier;
        font-size: 16px;
      }

      .flex {
        display: flex;
      }

      .flex-center {
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .big {
        margin: 0;
      }

      .bigCode .remark-code {
        font-size: 18px !important;
      }

      .column {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      .addition {
        box-sizing: border-box;
        height: 100%;
      }
      .codeBorder {
        border: 1px solid #ddd;
        padding: 5px;
      }

      .codeBorder h3 {
        margin: 0 !important;
      }

      .codeBorder pre {
        margin: 0;
      }

      .smallCode .remark-code {
        font-size: 12px !important;
      }

      .column-arrow {
        font-size: 60px !important;
        flex: 1;
        text-align: center;
        vertical-align: middle;
        justify-content: center;
        align-items: center;
        display: flex;
      }

      .plus {
        font-size: 60px !important;
        font-weight: bold;
        flex: 1;
        text-align: center;
        vertical-align: middle;
        justify-content: center;
        display: flex;
        padding: 0px;
        margin: 12px;
      }
      .equals {
        font-size: 60px !important;
        font-weight: bold;
        flex: 1;
        text-align: center;
      }
      .columnPlus {
        margin-top: 67px;
      }
      .marginTop {
        margin-top: 20px;
      }
      .smallJson pre {
        margin: 0;
      }
      .codeLine p {
        margin: 0;
      }
      .highlight {
        background-color: yellow;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Streaming HTTP and GraphQL

## Rob Richard
## Director, Front-End Engineering @ 1stdibs


???

* Hi! My name is Rob and I'm a Front-End Engineering @ 1stdibs.

---

<image style="width:100%" src="./1stdibs.png"/>

???
* 1stdibs is an online marketplace for rare and desireable goods. We sell Vintage and Antique Furniture, Jewelry, Fashion, and Art.
* Our front-end team is all-in on JavaScript. 
* Our stack is Node, GraphQL, React, & Relay.

---
## What are the best ways to load data into an application?

-   Minimize transfer size
-   Minimize round trips

???
* This talk is about different ways of loading data in a web application and the trade offs involved.
* Ideally we want to minimize the transfer size and the number of round trips before we can display something.
      

---

# Example App
.flex[
.column[
<img src="app.png" style="width:80%" />
]

.column[
-   A conference app with talks, speakers, and comments
]

]

???
* I'm going to use this simple app as an example.
* It's displaying information about JSKongress.
* It will list out the talks, speakers, and lets say you have the ability to leave comments, so we'll display those too.

---

# Rest

-   Typically one resource per request
-   Could require multiple round trips or waterfalls for each resource

???
* The first option for building the API for this would be to use REST-like endpoints.
* Typically you would create endpoints that return one resource per request.
* Let's see what that looks like

---

# Example App with Rest

.flex[

.column[
<img src="app.png" style="width:80%" />
]
.column.codeLine[
`GET` `/api/talks/`

.smallJson[
```json
[{
    id: 1,
    time: "10:30-11:00",
    speakerId: 5,
    title: "Opening Keynote"
}, ...]
```
]

<br>

`GET` <code>/api/speaker/<span class="highlight">5</span></code>

.smallJson[
```json
{
    id: 5,
    name: "Sean Larkin"
}
```
]

<br>

`GET` <code>/api/talk/<span class="highlight">1</span>/comments</code>

.smallJson[
```json
[{
    id: 9,
    body: "Loved this!"
}, ...]
```
]
]
]

???

* First we're going to load all the talks using the talks endpoint.
* We can use the returned talkId and speakerId to make additional calls to the speaker endpoint and comments endpoint to ge the rest of the data

---
# Rest waterfall

<img src="rest-waterfall.png" />

???

* The result of this is a "waterfall" of requests. 
* We can't start loading the speakers and the comments until the first request is finished.
* After that we can make all of those requests in parallel.

---
# GraphQL
* A data query language
* Developed by Facebook
* Used internally since 2012
* Open source version published in July 2015
* Specification: https://facebook.github.io/graphql

???
* Let's talk about GraphQL now. 
* I'll give a brief overview in case you're not familiar
* It's a language for querying data. 
* It was developed by Facebook to build their mobile apps
* It's published as a specification, so there are now many server and client implementations as well as developer tools that all interoperate nicely.

---
# GraphQL

-   Get many resources in a single request

<br />

<blockquote>
    "GraphQL queries access not just the properties of one resource but also smoothly follow
    references between them. While typical REST APIs require loading from multiple URLs, GraphQL
    APIs get all the data your app needs in a single request. Apps using GraphQL can be quick even
    on slow mobile network connections."
</blockquote>

## <center><cite>- graphql.org</cite></center>

???
* Here's a quote from the graphql website
* "GraphQL queries access not just the properties of one resource but also smoothly follow
  references between them. While typical REST APIs require loading from multiple URLs, GraphQL
  APIs get all the data your app needs in a single request. Apps using GraphQL can be quick even
  on slow mobile network connections."
* One of the main goals of GraphQL is to cut down on round trips. 
* It allows you to query for any amount of nested data in a single request

---
# Example App with GraphQL

.flex[

.column[
<img src="app.png" style="width:80%" />
]
.column.codeLine[
`POST` `/api/graphql/`

<br />

REQUEST

.smallJson[
```graphql
query {
  talks {
    title
    time
    speaker {
      name
    }
    comments {
      body
    }
  }
}
```
]
]
.column.codeLine[

.smallJson[
<br />
<br />

RESPONSE
<br />

```json
{
  "talks": [{
      "title": "Opening Keynote",
      "time": "10:30-11:00",
      "speaker": {
        "name": "Sean Larkin"
      },
      "comments": [{
        "body": "Loved this!"
      }]
    }, ...]
}
```
]

]
]

???
* Let's see what this looks like for our conference app.
* In GraphQL there is just one endpoint. Here it's /api/graphql.
* The client sends a request with a GraphQL query to this endpoint
* If you squint at it, a GraphQL request kind of looks like JSON, with only the keys
* The GraphQL server will process this response and return actual JSON in the same shape as the GraphQL request
* Since there's only one request we don't have to write code to coordinate sending the waterfall of REST requests.
* It's pretty common to wrap a REST api with a GraphQL server. 
* It's a mostly low cost way to start getting the benefits of using GraphQL in your client code without having the rewrite your whole backend from scratch.

---

# Why are fewer round trips faster?

-   Even if it’s same data speed
-   Even if you’re wrapping a REST api?


???
* The next question is, do you get any performance benefits by writing a GraphQL server, if all its doing is wrapping a REST api?

---

# Why are fewer round trips faster?

GraphQL server makes fast reliable network requests, same datacenter

Trimmed down data is sent over slow, spotty internet

.flex[
<img style="width: 100%" src="graphql-waterfall.png" />
]

???
* We're still making the same requests that the REST version of that app was making
* but it will be faster.
* because all of those round trips are happening over a fast datacenter connection. 
* Maybe they are even on the same physical server
* If those REST endpoints returned additional data that was not part of the GraphQL query, it will be trimmed down to the slim graphql response 
* A single small efficient payload is what gets sent over slow unreliable public internet.

---

# Every field is a function

.flex[

.column[
```graphql
query ($first: Int!) {
  talks {
    speaker {
*     picture(size: 300) {
        width
        height
        url
      }
    }
  }
}
```
]

.column[
```json
{
  "data": {
    "talks": [
      {
        "speaker": {
          "picture": {
            "width": 300,
            "height": 300,
            "url": "http://..."
          }
        }
      },
      ...
    ]
  }
}
```
]

]

???

* There's a few additional GraphQL features I want to talk about.
* The first is that every field in GraphQL can be thought of as a function
* Any field can take arguments
* In this case I added a picture field on the speaker, which accepts a size argument
* In your server implementation, you can write a function called a resolver to compute what the results of a field can be
* This gives you a lot of flexibility in defining your API

---
# Variables

* Parameterize GraphQL Queries

```graphql
query ($size: Int!) {
  talks {
    speaker {
      picture(size: $size) {
        width
        height
        url
      }
    }
  }
}

```

```json
{ "size": 30 }
```

???

* The next GraphQL feature is variables.
* This lets you define parameters that a GraphQL query can accept.
* You can then send an additional JSON payload with the variable data


---
# Fragments

* Reusable bits of GraphQL

```graphql
query {
  talks {
    title
    time
    speaker {
      name
    }
    ...Comments
  }
}

fragment Comments on Talk {
  comments {
    body
  }
}
```

???

* GraphQL also supports fragments.
* Fragments are reusable portions of a GraphQL Query.
* You can define a fragment and reuse it in multiple places in your query
* You can think of it as a building block of a GraphQL query. 
* Like how a React component is a building block of a React application 


---
# Directives

* Uses the @ character
* Can take arguments
* @include and @skip built into GraphQL Specification
* Experimental or framework specific features

```graphql
query($showSpeaker: Boolean!) {
  talks {
    title 
    time
    speaker @include(if: $showSpeaker) {
      name
    }
  }
}

```

???
* directives are these tokens you can add to almost any part of a GraphQL query
* The spec defines two of them: include and skip.
* Those let you conditionally request fields from a graphql query based on a variable value
* Directives are also used for expermental or framework specific graphql features

---

# Subscriptions

* Allow real time updates
* Modeled as an Observable

```graphql
subscription {
  talks {
    title 
    time
    speaker @include(if: $showSpeaker) {
      name
    }
  }
}
```

???
* GraphQL supports real time updates with subscriptions
* In this case instead of a query response model, it's closer to an observable.
* From one query you will receive multiple responses when the data changes
* Usually implemented with a technology like websockets

---
# Can we optimize further?

* Downsides to batching up all requests?
* Your page loads as fast as its slowest piece of data.

<img style="width: 80%; display:block; margin: 0 auto" src="graphql-waterfall2.png" />

???
* All of that is great and makes for a very seamless and efficient UI with great developer experience.
* But we could optimze further.
* There are downsides to batching up all of your requests
* Your page will load only as fast as its slowest piece of data

---

# Solution: Multiple graphql queries

Wait for first request to finish before second can begin

<img style="width: 80%; display:block; margin: 0 auto" src="graphql-waterfall-multiple.png" />

???

* This is the most common solution to this.
* You split your code up into mnultiple graphql queries and execute them as soon as you can 
* This is the most common approach to this issue
* The downsides are you need to write code to coordinate these requests, similar to what we did with our REST requests
* Also note that we waited until both the schedule and speakers finished loading, instead of just the schedule, so it will be slower overall.
* You could keep reworking this by splitting up your requests into even more graphql queries, but each time you do this you add more complexity to your code.


---

# `@defer` directive

-   Experimental new GraphQL feature
-   Gives clients a way to add boundaries to graphql requests
-   server can send results that are ready while the others are still parsing
-   client can begin rendering as data is received

---
# `@defer` directive

.flex[

.column.codeLine[
`POST` `/api/graphql/`

<br />

REQUEST

.smallJson[
```graphql
query {
  talks {
    title
    time
    speaker {
      name
    }
    comments @defer {
      body
    }
  }
}
```
]
]
.column.codeLine[

.smallJson[
<br />
<br />

Initial Response
<br />

```json
{
  "data": {
    "talks": [{
      "title": "Opening Keynote",
      "time": "10:30-11:00",
      "speaker": {
        "name": "Sean Larkin"
      },
      "comments": null
    }, ...]
  }
}
```
]

Deferred Response
<br />

```json
// Patch for "comments", sent for each talk
{
  "path": ["talks", 0, "comments"],
  "data":  [{
    "body": "Loved this!"
  }]
}
```
]


]
]


---

<img style="display: block; width: 75%; margin: 0 auto;" src="defer.gif" />

<small>
  <center>
  https://blog.apollographql.com/introducing-defer-in-apollo-server-f6797c4e9d6e
  </center>
</small>

---

# Implementation: HTTP Streaming

-   Multipart response like file uploads and emails
-   HTTP connection stays open until all data is received.
-   Requires a client that can stream data
    -   loop over data until enough bytes are read

---
# HTTP Streaming

.flex[

.column[
```
---
Content-Type: application/json
Content-Length: 790

{
  "data": {
    "talks": [{
      "title": "Opening Keynote",
      "time": "10:30-11:00",
      "speaker": {
        "name": "Sean Larkin"
      },
      "comments": null
    }, ...]
  }
}

---
Content-Type: application/json
Content-Length: 340

{
  "path": ["talks", 0, "comments"],
  "data":  [{
    "body": "Loved this!"
  }]
}
```
]
]

---
# Standard GraphQL Network Layer

Returns a promise with data

.bigCode[

```javascript
  function fetchGraphQL(query) {
    return fetch('/graphql', {
      headers: {
        'content-type': 'application/json'
      },
      body: JSON.stringify({query})
    }).then(response => {
      return response.json();
    })
  }
```

]

---
# Streaming GraphQL Network Layer

Use Readable Streams api to read bytes as they are recieved.

Returns a stream of response data. 

Similar to GraphQL Subscriptions

.bigCode[

```javascript
function fetchGraphQL({query, onNext, onComplete}) {
  return fetch('/graphql', {
    headers: {
      'content-type': 'application/json'
    },
    body: JSON.stringify({query})
  }).then(response => {
    const textDecoder = new TextDecoder();
    const patchResolver = new PatchResolver(r => onNext(r));
*   reader.read().then(function sendNext({ value, done }) {
      if (!done) {
        const plaintext = textDecoder.decode(value);
        patchResolver.handleChunk(plaintext);
*       reader.read().then(sendNext);
      } else {
        onComplete();
      }
    });
  })
}
```

]

---
# Parsing MultiPart HTTP Responses

.bigCode[

Custom PatchResolver class. 

Store previous data and apply and return patches

```javascript
function fetchGraphQL({query, onNext, onComplete}) {
  return fetch('/graphql', {
    headers: {
      'content-type': 'application/json'
    },
    body: JSON.stringify({query})
  }).then(response => {
    const textDecoder = new TextDecoder();
*   const patchResolver = new PatchResolver(r => onNext(r));
    reader.read().then(function sendNext({ value, done }) {
      if (!done) {
        const plaintext = textDecoder.decode(value);
*       patchResolver.handleChunk(plaintext);
        reader.read().then(sendNext);
      } else {
        onComplete();
      }
    });
  })
}
```

]

---
# Browser Support?

* ReadableStream API
  * ✅ Chrome
  * ✅ Firefox >= v65 (very recent)
  * ✅ Safari >= v10
  * ✅ Edge
  * ❌ Internet Explorer

---
# Use XMLHttpRequest as a fallback
.bigCode[

Works in all browsers

```javascript
function fetchGraphQLXHR({query, onNext, onComplete}) {
  const xhr = new XMLHttpRequest();
  let index = 0;

  const patchResolver = new PatchResolver(r => onNext(r));

  function onReadyStateChange() {
    if (this.readyState === this.DONE) {
      onComplete();
    } else {
      const chunk = xhr.response.substr(index);
      patchResolver.handleChunk(chunk);
      index = xhr.responseText.length;
    }
  }

  xhr.addEventListener('readystatechange', onReadyStateChange);
  xhr.send(JSON.stringify({query}));
}
```
]

---
# Open source implementation

* Included in apollo-client alpha 
* github.com/relay-tools/fetch-multipart-graphql/
  * Contains code to fetch and parse MultiPart HTML Response

---

# Why is this field `null`?

.flex[

.column[
because it's `null`?
  
or because it's loading? 
]


.column.codeLine[

.smallJson[
Initial Response
<br />

```json
{
  "data": {
    "talks": [{
      "title": "Opening Keynote",
      "time": "10:30-11:00",
      "speaker": {
        "name": "Sean Larkin"
      },
*     "comments": null
    }, ...]
  }
}
```
]

Deferred Response
<br />

```json
// Patch for "comments"
{
  "path": ["talks", 0, "comments"],
  "data":  [{
    "body": "Loved this!"
  }]
}
```
]
]

---
# Apollo Client

Supports `@defer` in alpha build

Provides `loadingState` prop to distinguish between pending and `null`.

```jsx
<Query query={query}>
  {({ loading, data, loadingState }) => {
    if (loading) {
      // entire query not yet loaded
      return <div>loading...</div>;
    }

    return (
      <React.Fragment>
        <h1>{data.talk.title}</h1>
        <h3>Comments</h3>
        {loadingState.talk.comments ? 
          <div>loading...</div>
          :
          <ul>
            {data.talk.comments.map(({body}) => (
              <li>{body</li><
            ))}
          </ul>
        }
      </React.Fragment>
    );
  }}
</Query>
```

---
# Relay

* Doesn't currently support @defer directly
* Does support observables, so it can work with the previous code example

---
# Relay

Relay's strength is combining GraphQL Fragments with React Components

```jsx

function Commments({talk}) {
  return (
    <ul>
      {talk.comments.map(({body}) => (
        <li>{body}</li>
      ))}
    </ul>
  )
}

export default createFragmentContainer(Comments, {
  talk: graphql`
    fragment Comments on Talk {
      comments {
        body
      }
    }
  `
})

```

---
# Relay

Deferred fragments and React Suspense are a perfect fit. 

```javascript

function Talk({talk}) {
  return (
    <React.Fragment>
      <h1>{talk.title}</h1>
      <h3>Comments</h3>
      <React.Suspense fallback={<div>loading...</div>}
        <Comments talk={talk} />
      </React.Suspense>
    </React.Fragment>
  )
}

export default createFragmentContainer(Comments, {
  talk: graphql`
    fragment Talk on Talk {
      title
      ...Comments @defer
    }
  `
})

```

---
# `@stream` directive

* Similar to @defer, but for lists
* Will load each element of the list as it is ready
* Get the first item in the list on the screen without waiting for the whole list


---
# `@stream` directive

.flex[

.column.codeLine[

REQUEST

.smallJson[
```graphql
query {
  talks @stream {
    title
    time
    speaker {
      name
    }
  }
}
```
]
]
.column.codeLine[

.smallJson[
```json
// Initial Response
{
  "data": {
    "talks": []
  }
}
```
]
.smallJson[
```json
// Patch for first talk
{
  "path": ["talks", 0],
  "data":  {
    "title": "Opening Keynote",
    "time": "10:30-11:00",
    "speaker": {
      "name": "Sean Larkin"
    }
  }
}
```
.smallJson[

```json
// Patch for second talk
{
  "path": ["talks", 1],
  "data":  {
    "title": "Knock knock, who’s there?",
    "time": "11:30-12:00",
    "speaker": {
      "name": "Sam Bellen"
    }
  }
}
```
]
]


]
]

---
# More Info
* Lee Byron - GraphQL Future at react-europe 2016
  * https://www.youtube.com/watch?v=ViXL0YQnioU
* Apollo Blog - Introducing @defer in Apollo Server
  * https://blog.apollographql.com/introducing-defer-in-apollo-server-f6797c4e9d6e


---
# That's all!
* https://www.1stdibs.com
* twitter: @rob_richard
* github: @robrichard

???
* That's all!
* Thank you so much!


    </textarea>
    <script
      src="https://remarkjs.com/downloads/remark-latest.min.js"
      type="text/javascript"
    ></script>
    <script type="text/javascript">
      var slideshow = remark.create({
        // highlightLanguage: 'javascript',
        highlightStyle: 'xcode',
        highlightLines: true,
        scroll: false,
        ratio: '4:3',
      });
    </script>
  </body>
</html>
